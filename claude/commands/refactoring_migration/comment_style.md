Always begin every code file with a Context Protocol header—a comprehensive comment block at the top of the file that serves as the primary source of contextual understanding for anyone reading the code. This header must go beyond superficial descriptions and provide deep architectural context: explain what this file accomplishes and why it exists within the broader codebase, describe its specific role and responsibilities in relation to other system components, document what functions or classes it contains and their purposes, identify similar or related files that handle adjacent concerns or share patterns, note any critical dependencies or integration points, and include any other information that would help a developer understand not just what the code does but why it's structured this way and how it fits into the system's design. The Context Protocol should be substantial enough that someone unfamiliar with the codebase can read this header and immediately understand the file's purpose, scope, and relationships without needing to reverse-engineer context from the code itself. This is not a brief summary—it's a deliberate exercise in making the file self-documenting at the architectural level.

For commenting throughout the file, follow this structure exactly: every function must have a single, concise docstring of one to two sentences maximum that states what the function does—nothing more. Do not include section separator comments, visual divider lines, or any "decorator" comments that attempt to organize code into labeled sections (no "# ===== Helper Functions =====" or "# --- Authentication Logic ---" blocks). Beyond docstrings, use inline comments sparingly and strategically: comments should serve as plain English translations of what specific code blocks are doing, written in short, simple statements that explain the actual operations being performed. These inline comments act as structured narration of the code's behavior (e.g., "# Extract user ID from token payload" or "# Validate required fields before database write"), not as redundant restatements of obvious syntax. The goal is clarity through minimalism—docstrings establish function purpose, inline comments clarify non-obvious operations, and the code itself remains the primary documentation without visual clutter or over-explanation.
