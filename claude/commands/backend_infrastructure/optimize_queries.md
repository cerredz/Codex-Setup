When optimizing MongoDB queries, begin by examining both the queries file and the backend routes file to understand the full data flow—how routes call queries, what data they request, and how responses are shaped before being returned. For each query, evaluate whether it is fetching more fields or documents than necessary; use projection to return only required fields and ensure filters are specific enough to avoid scanning unnecessary documents. Identify queries that would benefit from indexing by analyzing filter conditions, sort operations, and fields used in lookups—flag any query filtering or sorting on unindexed fields as a performance risk. Look for N+1 patterns where routes make multiple sequential database calls that could be consolidated into a single aggregation pipeline or bulk operation. Evaluate whether any queries are being called repeatedly with identical parameters within the same request cycle and recommend caching or restructuring where appropriate. For each optimization you identify, explain the current inefficiency, the proposed change, and the expected performance impact so that tradeoffs are visible and reviewable before implementation.
